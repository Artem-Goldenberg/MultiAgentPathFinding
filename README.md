# CBSLab
## Имплементация $A*$ на $C$
### `Установка`
Нужно склонировать репозиторий и установить необходимыe зависимости.
```
git clone https://github.com/Maxon081102/CBSLab
cd CBSLab
pip install -r requirements.txt
```

После этого надо сбилдить расширение для Питона, написанное на C (все файлы хранятся в папке `CExtension`).    
Можно создать библиотеку прямо в папке проекта, для этого подготовлен файл `setup.py`.
```
python setup.py build_ext --inplace
```

Теперь можно работать уже только с питоном и запускать его файлы.  

*Потом надо сделать main.py и все такое*.  
Но сейчас основной файл - это `Tests/test.py`.  
Через него можно тестить любой cbs алгоритм. (Пока что есть тесты, проверяющие алгоритм на корректность работы
`test_correctness()` и тест, который можно самому запускать с разными картами `simple_test()`, примеры есть в ноутбуке `Tests/showcase.ipynb`).

### Про папки

Есть папка `Primitives`, в ней находятся всякие вспомогательные классы для cbs. В папке `Tests` происходит самое интересное, там рисуется картинка с помощью `graphics.py` и храняться вообще все тесты пока что (это в папке `instances`)

Есть файл `cbs.py`, там реализован алгоритм cbs и код для вызова $A*$ (можно посмотреть как пример последнюю функцию, ну там скорее всего ничего не понятно все равно, я уже просто так долго над этим работал что не знаю насколько это вообще все понятно написано, так что по вопросам пишите).  
И + всякие дополнительные файлы типа `search_tree.py` где лежат всякие обертки над чем-то.

*Еще пометка*
Чтобы можно было потом тестить любой cbs, если будете делать какое-то улучшение cbs, можете пожалуйста делать, чтобы он принимал на вход `MAPF` объект (`mapf.py` - это просто обертка для карты и начальных и конечных путей агентов, но оно оказалось очень удобным) и выдавал на выход либо конечную `Node` либо `None`, то есть либо нашел решение либо нет. (Понятно что для дебага и тестов можно еще добавить количество шагов например, но это можно добавить в ноду, ну и скорее всего это я и буду делать). Если каждый алгоритм будет иметь такую сигнатуру, то будет классно

<details open>
<summary>Как дебажить A*</summary>
<br>
Если нужно посмотреть, все ли норм с астаром, то объясню, как он вообще работает.

Вот в папке `CExtension` есть куча файлов, самый важный - `Algorithm.c` в нем функция `findPath` - и есть $A*$  
Она использует свои cобственные `Map`, `PriorityQueue`, `vector` и тд, для каждого по своему хедеру (constraints обрабатываются в `Map.h` и `Map.c`).

В первую очередь что можно сделать, это в файле `lightspeed.c` (где связываются C и python) раскомментировать строчку c `DebugMode` и сбилдить C код заново (`python setup.py build_ext --inplace`)

Тогда по каждому вызову $A*$ начнет печатать дебаг информацию про пришедшие в него пути, ограничения и тд. 

Потом, если кажется что все приходит нормально и хочется протестить сам алгоритм, найти какой-то путь, с какими-то ограничениями, то в том же `Algorithm.c` есть функция `testPath` там можно выбрать свою стартовую и целевую точку, карта задается там массивом 1 и 0. 1 - Стенка, нет прохода, 0 - есть проход. Массив байтов, все сваливается в один, одномерный массив и потом различается с помощью width и heigth.  
Также можно задать ограничения. там в примере, это есть. Нужно просто изменить ограничения которые лежат в массиве на те, которые вам нужны. Если вам не нужно никаких ограничений этого вида (реберных или вершинных), то тогда лучше передать `NULL` вместо чего-то дургого. Это там тоже написанно. Чтобы запустить, нужно просто расскомментировать main. Он отработает и выведет путь на экран.  
 Потом не забудьте закоментировать и не забывайте делать `python setup.py build_ext --inline` если внесли изменения в С код и надо чтобы их видел питон. 
</details>